# -*- coding: utf-8 -*-
"""Breast_Cancer_Prediction

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1guXDh9rGSHNZ9Qij24NKMp_cK90xMsKu
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import classification_report
from scipy import linalg
import matplotlib as mpl
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix, roc_curve, auc

!pip list

data = pd.read_csv('/content/data.csv')

#sample view of the data
data.head()

data.drop(['Unnamed: 32','id'],axis=1,inplace=True)

#data overview
data.info()

#targets distribution
data['diagnosis'].unique()

#statistical overview of the data
data.describe().T

#targets distribution
data['diagnosis'].value_counts().plot.bar()
plt.show()

sns.boxplot(y='radius_mean',x='diagnosis',
            data=data)
plt.show()

sns.scatterplot(y='smoothness_mean',x='diagnosis',data=data)
plt.show()

sns.violinplot(x='area_mean',data=data)
plt.title('violin plot of area mean')
plt.show()

data.columns

#slicing the dataset with mean values
data_mean = data.iloc[:,0:12]
data_mean

sns.pairplot(data=data_mean)
plt.show()

#slicing the dataset into se values
data_se = data.iloc[:,11:21]
sns.pairplot(data=data_se)
plt.show()

#slicing the data with worst parameters
data_worst = data.iloc[:,21:]
sns.pairplot(data=data_worst)
plt.show()

#correlation plot
plt.figure(figsize=(20,20))
sns.heatmap(data.corr(),annot=True)
plt.show()

le = LabelEncoder()
data['diagnosis'] = le.fit_transform(data['diagnosis'])

#seperating features and targets
X = data.drop('diagnosis',axis=1)
y = data['diagnosis']


#splitting the data
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3)

#base line model
baseline_model = SVC()
baseline_model.fit(X_train,y_train)

#baseline model predictions
base_preds = baseline_model.predict(X_test)

print(classification_report(base_preds,y_test))

#initializing the LDA object and choosing the components
lda = LinearDiscriminantAnalysis(n_components=1)
qda = QuadraticDiscriminantAnalysis()
X_train_lda = lda.fit_transform(X_train,y_train)
X_test_lda = lda.transform(X_test)
# Print the shape of the original data and the transformed data
print("Original Data shape:",X.shape, "\nModified Data shape:", X_train.shape)

#base model
model = SVC()
model.fit(X_train_lda,y_train)

#predictions
preds = model.predict(X_test_lda)

#classification report
print(classification_report(y_test,preds))

#confusion matrix
sns.heatmap(confusion_matrix(y_test,preds),annot=True,fmt='g')
plt.show()

qda = QuadraticDiscriminantAnalysis()
# Training
qda.fit(X_train, y_train.ravel())
# Prediction
y_prob_qda = qda.predict_proba(X_test)[:, 1]
y_pred_qda = np.where(y_prob_qda > 0.5, 1, 0)

print(classification_report(y_test,y_pred_qda))

confusion_matrix_qda = confusion_matrix(y_test, y_pred_qda)
false_positive_rate_qda, true_positive_rate_qda, thresholds = roc_curve(
    y_test, y_prob_qda
    )
roc_auc_qda = auc(false_positive_rate_qda, true_positive_rate_qda)

#confusion matrix
sns.heatmap(confusion_matrix_qda,annot=True,fmt='g')
plt.show()

def plot_roc(roc_auc, false_positive_rate, true_positive_rate):
  plt.figure(figsize=(6, 6))
  plt.title('Receiver Operating Characteristics')
  plt.plot(false_positive_rate, true_positive_rate, color='red', label='AUC = {:.2f}'.format( roc_auc))
  plt.legend(loc = 'lower right')
  plt.plot([0, 1], [0, 1], linestyle='--')
  plt.axis('tight')
  plt.ylabel('True Positive Rtae')
  plt.xlabel('False Positive Rtae')

plot_roc(roc_auc_qda, false_positive_rate_qda, true_positive_rate_qda)